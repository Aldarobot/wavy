//! Generated by DL API

#![allow(unsafe_code)]
#![rustfmt::skip]

use std::ffi::{c_void, c_char, c_int, c_long};
use std::ptr::NonNull;
use std::convert::TryInto;

const LM_ID_NEWLM: c_long = -1;
const RTLD_NOW: c_int = 0x00002;

extern {
    fn dlmopen(lmid: c_long, filename: *const c_char, flags: c_int)
        -> *mut c_void;
    fn dlclose(handle: *mut c_void) -> c_int;
    fn dlsym(handle: *mut c_void, symbol: *const c_char) -> *mut c_void;
}

unsafe fn new(name: &[u8]) -> Option<NonNull<c_void>> {
    NonNull::new(dlmopen(LM_ID_NEWLM, name.as_ptr().cast(), RTLD_NOW))
}

unsafe fn old(dll: NonNull<c_void>) {
    assert_eq!(dlclose(dll), 0);
}

unsafe fn sym(dll: &NonNull<c_void>, name: &[u8]) -> Option<NonNull<c_void>> {
    NonNull::new(dlsym(dll, name.as_ptr().cast()))
}

static mut THREAD_ID: std::mem::MaybeUninit<std::thread::ThreadID>
    = std::mem::MaybeUninit::uninit();
static mut DLL: std::mem::MaybeUninit<NonNull<c_void>>
    = std::mem::MaybeUninit::uninit();
static mut START_FFI: std::sync::Once = std::sync::Once::new();

unsafe fn check_thread() -> Option<NonNull<c_void>> {
    START_FFI.call_once(||
        THREAD_ID = std::mem::MaybeUninit::new(std::thread::current().id());
        if let Some(dll) = new(DL_API_SHARED_OBJECT_NAME) {
            DLL = dll;
        }
    );

    assert_eq!(THREAD_ID.assume_init(), std::thread::current().id());
}

const DL_API_SHARED_OBJECT_NAME: &[u8] = b"libasound.so.2\0";

/// PCM stream (direction)
#[repr(C)]
#[non_exhaustive]
pub(crate) enum SndPcmStream {
    /// Playback stream
    Playback = 0,
    /// Capture stream
    Capture,
}

/// PCM access type
#[repr(C)]
#[non_exhaustive]
pub(crate) enum SndPcmAccess {
    /// mmap access with simple interleaved channels
    MmapInterleaved = 0,
    /// mmap access with simple non interleaved channels
    MmapNoninterleaved,
    /// mmap access with complex placement
    MmapComplex,
    /// snd_pcm_readi/snd_pcm_writei access
    RwInterleaved,
    /// snd_pcm_readn/snd_pcm_writen access
    RwNoninterleaved,
}

/// PCM sample format
#[repr(C)]
#[non_exhaustive]
pub(crate) enum SndPcmFormat {
    /// Unknown
    Unknown = -1,
    /// Signed 8 bit
    S8 = 0,
    /// Unsigned 8 bit
    U8,
    /// Signed 16 bit Little Endian (a.k.a `S16` in C API)
    S16Le,
    /// Signed 16 bit Big Endian
    S16Be,
    /// Unsigned 16 bit Little Endian (a.k.a `U16` in C API)
    U16Le,
    /// Unsigned 16 bit Big Endian
    U16Be,
    /// Signed 24 bit Little Endian using low three bytes in 32-bit word
    /// (a.k.a `S24` in C API)
    S24Le,
    /// Signed 24 bit Big Endian using low three bytes in 32-bit word
    S24Be,
    /// Unsigned 24 bit Little Endian using low three bytes in 32-bit word
    /// (a.k.a `U24` in C API)
    U24Le,
    /// Unsigned 24 bit Big Endian using low three bytes in 32-bit word
    U24Be,
    /// Signed 32 bit Little Endian (a.k.a `S32` in C API)
    S32Le,
    /// Signed 32 bit Big Endian
    S32Be,
    /// Unsigned 32 bit Little Endian (a.k.a `U32` in C API)
    U32Le,
    /// Unsigned 32 bit Big Endian
    U32Be,
    /// Float 32 bit Little Endian, Range -1.0 to 1.0
    /// (a.k.a `FLOAT` in C API)
    FloatLe,
    /// Float 32 bit Big Endian, Range -1.0 to 1.0
    FloatBe,
    /// Float 64 bit Little Endian, Range -1.0 to 1.0
    /// (a.k.a `FLOAT64` in C API)
    Float64Le,
    /// Float 64 bit Big Endian, Range -1.0 to 1.0
    Float64Be,
    /// IEC-958 Little Endian (a.k.a `IEC958_SUBFRAME` in C API)
    Iec958SubframeLe,
    /// IEC-958 Big Endian
    Iec958SubframeBe,
    /// Mu-Law
    MuLaw,
    /// A-Law
    ALaw,
    /// Ima-ADPCM
    ImaAdpcm,
    /// MPEG
    Mpeg,
    /// GSM
    Gsm,
    /// Signed 20bit Little/Native Endian in 4bytes format, LSB justified
    /// (a.k.a `S20` in C API)
    S20Le,
    /// Signed 20bit Big Endian in 4bytes format, LSB justified
    S20Be,
    /// Unsigned 20bit Little/Native Endian in 4bytes format, LSB justified
    /// (a.k.a `U20` in C API)
    U20Le,
    /// Unsigned 20bit Big Endian in 4bytes format, LSB justified
    U20Be,
    /// Special
    Special = 31,
    /// Signed 24bit Little Endian in 3bytes format
    S243le = 32,
    /// Signed 24bit Big Endian in 3bytes format
    S243be,
    /// Unsigned 24bit Little Endian in 3bytes format
    U243le,
    /// Unsigned 24bit Big Endian in 3bytes format
    U243be,
    /// Signed 20bit Little Endian in 3bytes format
    S203le,
    /// Signed 20bit Big Endian in 3bytes format
    S203be,
    /// Unsigned 20bit Little Endian in 3bytes format
    U203le,
    /// Unsigned 20bit Big Endian in 3bytes format
    U203be,
    /// Signed 18bit Little Endian in 3bytes format
    S183le,
    /// Signed 18bit Big Endian in 3bytes format
    S183be,
    /// Unsigned 18bit Little Endian in 3bytes format
    U183le,
    /// Unsigned 18bit Big Endian in 3bytes format
    U183be,
    /// Signed 16 bit CPU endian
    G72324,
    /// Unsigned 16 bit CPU endian
    G723241b,
    /// Signed 24 bit CPU endian
    G72340,
    /// Unsigned 24 bit CPU endian
    G723401b,
    /// Signed 32 bit CPU endian
    DsdU8,
    /// Unsigned 32 bit CPU endian
    DsdU16Le,
    /// Float 32 bit CPU endian
    DsdU32Le,
    /// Float 64 bit CPU endian
    DsdU16Be,
    /// IEC-958 CPU Endian
    DsdU32Be,
}

/// PCM handle
#[repr(C)]
pub struct snd_pcm_t(*mut [u8]);

/// PCM hardware configuration space container
/// 
/// snd_pcm_hw_params_t is an opaque structure which contains a set of
/// possible PCM hardware configurations. For example, a given instance might
/// include a range of buffer sizes, a range of period sizes, and a set of
/// several sample formats. Some subset of all possible combinations these
/// sets may be valid, but not necessarily any combination will be valid.
/// 
/// When a parameter is set or restricted using a snd_pcm_hw_params_set*
/// function, all of the other ranges will be updated to exclude as many
/// impossible configurations as possible. Attempting to set a parameter
/// outside of its acceptable range will result in the function failing and
/// an error code being returned.
#[repr(C)]
pub struct snd_pcm_hw_params_t(*mut [u8]);

impl Drop for snd_pcm_hw_params_t {
    fn drop(&mut self) {
        snd_pcm_hw_params_free(self.0);
    }
}

/// PCM status container
#[repr(C)]
pub struct snd_pcm_status_t(*mut [u8]);

impl snd_pcm_status_t {
    unsafe fn uninit() -> Self {
        Self(Vec::<u8>::with_capacity(snd_pcm_status_sizeof).into_boxed_slice().into_raw());
    }
}

impl Drop for snd_pcm_status_t {
    fn drop(&mut self) {
        let _ = unsafe { Box::<[u8]>::from_raw(self.0) }
    }
}

static mut FUNC_SND_PCM_OPEN: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_MALLOC: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_ANY: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_SET_RATE_RESAMPLE: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_SET_ACCESS: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_SET_FORMAT: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_SET_CHANNELS: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_SET_RATE_NEAR: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_GET_BUFFER_SIZE: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_GET_PERIOD_SIZE: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_HW_PARAMS_FREE: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_PREPARE: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_WRITEI: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_READI: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_STATUS_MALLOC: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_LONG: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_CLOSE: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

static mut FUNC_SND_PCM_START: std::mem::MaybeUninit<extern fn(
    
) -> > = std::mem::MaybeUninit::uninit();

/// A module contains functions.
pub struct Player;

impl Player {
    /// Opens a PCM.
    /// - `pcmp`: Returned PCM handle
    /// - `name`: ASCII identifier of the PCM handle
    /// - `stream`: Wanted stream
    /// - `mode`: Open mode (see SND_PCM_NONBLOCK, SND_PCM_ASYNC)
    /// Return 0 on success otherwise a negative error code
    fn snd_pcm_open()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_OPEN).assume_init())() };
    }

    /// Allocate an invalid snd_pcm_hw_params_t using standard malloc
    fn snd_pcm_hw_params_malloc()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_MALLOC).assume_init())() };
    }

    /// Fill params with a full configuration space for a PCM.
    fn snd_pcm_hw_params_any()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_ANY).assume_init())() };
    }

    /// Restrict a configuration space to contain only real hardware rates.
    /// - `pcm`: PCM handle
    /// - `params`: Configuration space 
    /// - `val`: 0 = disable, 1 = enable (default) rate resampling
    fn snd_pcm_hw_params_set_rate_resample()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_RATE_RESAMPLE).assume_init())() };
    }

    /// Restrict a configuration space to contain only one access type.
    /// - `pcm`: PCM handle
    /// - `params`: Configuration space
    /// - `access`: access type
    fn snd_pcm_hw_params_set_access()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_ACCESS).assume_init())() };
    }

    /// Restrict a configuration space to contain only one format.
    fn snd_pcm_hw_params_set_format()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_FORMAT).assume_init())() };
    }

    /// Restrict a configuration space to contain only one channels count.
    fn snd_pcm_hw_params_set_channels()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_CHANNELS).assume_init())() };
    }

    /// Restrict a configuration space to have rate nearest to a target.
    /// - `pcm`: PCM handle
    /// - `params`: Configuration space
    /// - `val`: approximate target rate / returned approximate set rate
    /// - `dir`: Sub unit direction 
    fn snd_pcm_hw_params_set_rate_near()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_RATE_NEAR).assume_init())() };
    }

    /// Install one PCM hardware configuration chosen from a configuration space
    /// and snd_pcm_prepare it.
    /// - `pcm`: PCM handle
    /// - `params`: Configuration space definition container
    fn snd_pcm_hw_params()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS).assume_init())() };
    }

    /// Extract buffer size from a configuration space.
    /// - `params`: Configuration space
    /// - `val`: Returned buffer size in frames
    fn snd_pcm_hw_params_get_buffer_size()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_GET_BUFFER_SIZE).assume_init())() };
    }

    /// Extract period size from a configuration space.
    /// - `params`: Configuration space
    /// - `val`: Returned approximate period size in frames
    /// - `dir`: Sub unit direction
    fn snd_pcm_hw_params_get_period_size()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_GET_PERIOD_SIZE).assume_init())() };
    }

    /// Frees a previously allocated snd_pcm_hw_params_t
    fn snd_pcm_hw_params_free()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_FREE).assume_init())() };
    }

    /// Prepare PCM for use.
    fn snd_pcm_prepare()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_PREPARE).assume_init())() };
    }

    /// Write interleaved frames to a PCM.
    /// - `pcm`: PCM handle
    /// - `buffer`: frames containing buffer
    /// - `size`: frames to be written
    /// If the blocking behaviour is selected and it is running, then routine
    /// waits until all requested frames are played or put to the playback ring
    /// buffer. The returned number of frames can be less only if a signal or
    /// underrun occurred.
    /// 
    /// If the non-blocking behaviour is selected, then routine doesn't wait at
    /// all.
    fn snd_pcm_writei()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_WRITEI).assume_init())() };
    }

    /// Obtain status (runtime) information for PCM handle. 
    /// - `pcm`: PCM handle
    /// - `status`: Status container
    fn snd_pcm_status_malloc()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_STATUS_MALLOC).assume_init())() };
    }

    /// Get number of frames available from a PCM status container (see
    /// snd_pcm_avail_update)
    fn long()
        -> 
    {
        let _ret = unsafe { ((FUNC_LONG).assume_init())() };
    }

    /// close PCM handle
    fn snd_pcm_close()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_CLOSE).assume_init())() };
    }

    /// Start a PCM.
    fn snd_pcm_start()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_START).assume_init())() };
    }

}

/// A module contains functions.
pub struct Recorder;

impl Recorder {
    /// Opens a PCM.
    /// - `pcmp`: Returned PCM handle
    /// - `name`: ASCII identifier of the PCM handle
    /// - `stream`: Wanted stream
    /// - `mode`: Open mode (see SND_PCM_NONBLOCK, SND_PCM_ASYNC)
    /// Return 0 on success otherwise a negative error code
    fn snd_pcm_open()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_OPEN).assume_init())() };
    }

    /// Allocate an invalid snd_pcm_hw_params_t using standard malloc
    fn snd_pcm_hw_params_malloc()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_MALLOC).assume_init())() };
    }

    /// Fill params with a full configuration space for a PCM.
    fn snd_pcm_hw_params_any()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_ANY).assume_init())() };
    }

    /// Restrict a configuration space to contain only real hardware rates.
    /// - `pcm`: PCM handle
    /// - `params`: Configuration space 
    /// - `val`: 0 = disable, 1 = enable (default) rate resampling
    fn snd_pcm_hw_params_set_rate_resample()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_RATE_RESAMPLE).assume_init())() };
    }

    /// Restrict a configuration space to contain only one access type.
    /// - `pcm`: PCM handle
    /// - `params`: Configuration space
    /// - `access`: access type
    fn snd_pcm_hw_params_set_access()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_ACCESS).assume_init())() };
    }

    /// Restrict a configuration space to contain only one format.
    fn snd_pcm_hw_params_set_format()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_FORMAT).assume_init())() };
    }

    /// Restrict a configuration space to contain only one channels count.
    fn snd_pcm_hw_params_set_channels()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_CHANNELS).assume_init())() };
    }

    /// Restrict a configuration space to have rate nearest to a target.
    /// - `pcm`: PCM handle
    /// - `params`: Configuration space
    /// - `val`: approximate target rate / returned approximate set rate
    /// - `dir`: Sub unit direction 
    fn snd_pcm_hw_params_set_rate_near()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_SET_RATE_NEAR).assume_init())() };
    }

    /// Install one PCM hardware configuration chosen from a configuration space
    /// and snd_pcm_prepare it.
    /// - `pcm`: PCM handle
    /// - `params`: Configuration space definition container
    fn snd_pcm_hw_params()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS).assume_init())() };
    }

    /// Extract buffer size from a configuration space.
    /// - `params`: Configuration space
    /// - `val`: Returned buffer size in frames
    fn snd_pcm_hw_params_get_buffer_size()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_GET_BUFFER_SIZE).assume_init())() };
    }

    /// Extract period size from a configuration space.
    /// - `params`: Configuration space
    /// - `val`: Returned approximate period size in frames
    /// - `dir`: Sub unit direction
    fn snd_pcm_hw_params_get_period_size()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_GET_PERIOD_SIZE).assume_init())() };
    }

    /// Frees a previously allocated snd_pcm_hw_params_t
    fn snd_pcm_hw_params_free()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_HW_PARAMS_FREE).assume_init())() };
    }

    /// Prepare PCM for use.
    fn snd_pcm_prepare()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_PREPARE).assume_init())() };
    }

    /// Read interleaved frames from a PCM.
    /// - `pcm`: PCM handle
    /// - `buffer`: frames containing buffer
    /// - `size`: frames to be read
    /// If the blocking behaviour was selected and it is running, then routine
    /// waits until all requested frames are filled. The returned number of
    /// frames can be less only if a signal or underrun occurred.
    /// 
    /// If the non-blocking behaviour is selected, then routine doesn't wait at
    /// all.
    fn snd_pcm_readi()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_READI).assume_init())() };
    }

    /// Obtain status (runtime) information for PCM handle. 
    /// - `pcm`: PCM handle
    /// - `status`: Status container
    fn snd_pcm_status_malloc()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_STATUS_MALLOC).assume_init())() };
    }

    /// Get number of frames available from a PCM status container (see
    /// snd_pcm_avail_update)
    fn long()
        -> 
    {
        let _ret = unsafe { ((FUNC_LONG).assume_init())() };
    }

    /// close PCM handle
    fn snd_pcm_close()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_CLOSE).assume_init())() };
    }

    /// Start a PCM.
    fn snd_pcm_start()
        -> 
    {
        let _ret = unsafe { ((FUNC_SND_PCM_START).assume_init())() };
    }

}

